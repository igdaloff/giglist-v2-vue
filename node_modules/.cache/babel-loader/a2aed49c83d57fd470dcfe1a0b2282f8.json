{"ast":null,"code":"import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString, vModelSelect as _vModelSelect, createElementVNode as _createElementVNode, withDirectives as _withDirectives, createCommentVNode as _createCommentVNode } from \"vue\";\nvar _hoisted_1 = [\"value\"];\nvar _hoisted_2 = {\n  key: 0,\n  src: \"{spotifyEmbedUrl}\",\n  frameborder: \"0\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(_Fragment, null, [_withDirectives(_createElementVNode(\"select\", {\n    \"onUpdate:modelValue\": _cache[0] || (_cache[0] = function ($event) {\n      return $data.selected = $event;\n    }),\n    onChange: _cache[1] || (_cache[1] = function () {\n      return $options.getCityData && $options.getCityData.apply($options, arguments);\n    })\n  }, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList($data.cities, function (city) {\n    return _openBlock(), _createElementBlock(\"option\", {\n      key: city.id,\n      value: city.id\n    }, _toDisplayString(city.label), 9\n    /* TEXT, PROPS */\n    , _hoisted_1);\n  }), 128\n  /* KEYED_FRAGMENT */\n  ))], 544\n  /* HYDRATE_EVENTS, NEED_PATCH */\n  ), [[_vModelSelect, $data.selected]]), _createElementVNode(\"p\", null, _toDisplayString($data.randomGigVenue), 1\n  /* TEXT */\n  ), _createElementVNode(\"p\", null, _toDisplayString($data.randomGigUrl), 1\n  /* TEXT */\n  ), _createElementVNode(\"p\", null, _toDisplayString($data.randomGigDayOfWeek), 1\n  /* TEXT */\n  ), _createElementVNode(\"p\", null, _toDisplayString($data.randomGigMonth), 1\n  /* TEXT */\n  ), _createElementVNode(\"p\", null, _toDisplayString($data.randomGigDay), 1\n  /* TEXT */\n  ), _createElementVNode(\"p\", null, _toDisplayString($data.randomGigArtist), 1\n  /* TEXT */\n  ), {\n    spotifyEmbedUrl: $data.spotifyEmbedUrl\n  } ? (_openBlock(), _createElementBlock(\"iframe\", _hoisted_2)) : _createCommentVNode(\"v-if\", true)], 64\n  /* STABLE_FRAGMENT */\n  );\n}","map":{"version":3,"mappings":";;;;EAWiCA,GAAG,EAAC;EAAoBC,WAAW,EAAC;;;6EAVnEC,oBAES,QAFT,EAES;;aAFQC,iBAAQC;MAEhB;IAFmBC,QAAM;MAAA,OAAEC,uEAAF;IAAA;EAEzB,CAFT,sBACEC,oBAAwFC,SAAxF,EAAwF,IAAxF,EAAwFC,YAAjEN,YAAiE,EAA3D,UAAdO,IAAc,EAAV;yBAAnBH,oBAAwF,QAAxF,EAAwF;MAAxDI,GAAG,EAAED,IAAI,CAACE,EAA8C;MAAzCC,KAAK,EAAEH,IAAI,CAACE;IAA6B,CAAxF,mBAAkEF,IAAI,CAACI,MAAvE,EAA4E;IAAA;IAA5E,EAA4EC,UAA5E;GAAwF,CAAxF;;EAAA,GADF;;EAAA,oBAAiBZ,mBAGjBD,oBAA2B,GAA3B,EAA2B,IAA3B,EAA2Bc,iBAArBb,oBAAqB,CAA3B,EAAoB;EAAA;EAApB,GACAD,oBAAyB,GAAzB,EAAyB,IAAzB,EAAyBc,iBAAnBb,kBAAmB,CAAzB,EAAkB;EAAA;EAAlB,GACAD,oBAA+B,GAA/B,EAA+B,IAA/B,EAA+Bc,iBAAzBb,wBAAyB,CAA/B,EAAwB;EAAA;EAAxB,GACAD,oBAA2B,GAA3B,EAA2B,IAA3B,EAA2Bc,iBAArBb,oBAAqB,CAA3B,EAAoB;EAAA;EAApB,GACAD,oBAAyB,GAAzB,EAAyB,IAAzB,EAAyBc,iBAAnBb,kBAAmB,CAAzB,EAAkB;EAAA;EAAlB,GACAD,oBAA4B,GAA5B,EAA4B,IAA5B,EAA4Bc,iBAAtBb,qBAAsB,CAA5B,EAAqB;EAAA;EAArB;qBAEcA;qBAAdI,oBAAgF,QAAhF","names":["src","frameborder","_createElementVNode","$data","$event","onChange","$options","_createElementBlock","_Fragment","_renderList","city","key","id","value","label","_hoisted_1","_toDisplayString"],"sourceRoot":"","sources":["/Users/nathan/Sites/giglist-v2-vue/src/components/CitySelect.vue"],"sourcesContent":["<template>\n  <select v-model=\"selected\" @change=\"getCityData\">\n    <option v-for=\"city in cities\" :key=\"city.id\" :value=\"city.id\">{{ city.label }}</option>\n  </select>\n  <p>{{ randomGigVenue }}</p>\n  <p>{{ randomGigUrl }}</p>\n  <p>{{ randomGigDayOfWeek }}</p>\n  <p>{{ randomGigMonth }}</p>\n  <p>{{ randomGigDay }}</p>\n  <p>{{ randomGigArtist }}</p>\n  \n  <iframe v-if={spotifyEmbedUrl} src=\"{spotifyEmbedUrl}\" frameborder=\"0\"></iframe>\n</template>\n\n<script>\n\nimport cityData from \"../data/songkickCityData.js\"\n\nexport default {\n  data() {\n    return {\n      selected: 7644,\n      cities: cityData,\n      songkickData: [],      \n      randomGigVenue: '',\n      randomGigUrl: '',\n      randomGigDayOfWeek: '',\n      randomGigMonth: '',\n      randomGigDay: '',\n      randomGigArtist: '',\n      spotifyToken: '',\n      spotifyEmbedUrl: ''\n    }\n  },\n  methods: {\n    async getCityData(e) {\n\n      // Store city ID from selected <option> value in a variable\n      const songkickCityId = e.target.value\n\n      // Using the getSongkickUrl method, generate a URL using the ID and date from above\n      let songkickUrl = this.getSongkickUrl(songkickCityId)      \n\n      // Fetch data from the URL generated above and extract it as a JSON object; Note: I'm using await/async instead of .then() chains, I think because it's cleaner and easier to read but not entirely sure\n      const response = await fetch(songkickUrl)\n      const responseJSON = await response.json()\n\n      // Store returned data in songkickData array defined above      \n      this.songkickData = responseJSON\n              \n      this.getRandomGigData()\n    },\n    getSongkickUrl(songkickCityId) {\n      const now = new Date()\n      const today = now.toISOString().slice(0, 10)\n      const songkickAPIKey = 'RpuYqxFiPPsJPs5l'\n      let songkickUrl = `https://api.songkick.com/api/3.0/metro_areas/${songkickCityId}/calendar.json?min_date=${today}&apikey=${songkickAPIKey}`;\n      \n      return songkickUrl\n    },\n    getRandomGigData() {      \n      const listOfGigs = this.songkickData.resultsPage.results.event\n      const randomGig = listOfGigs[Math.floor(Math.random()*listOfGigs.length)];\n      const randomGigDate = new Date(randomGig.start.datetime);\n      this.randomGigVenue = randomGig.venue.displayName;\n      this.randomGigUrl = randomGig.uri;      \n      this.randomGigDayOfWeek = randomGigDate.toLocaleString('default', { weekday: 'long' });\n      this.randomGigMonth = randomGigDate.toLocaleString('default', { month: 'long' });\n      this.randomGigDay = randomGigDate.getDate();\n      this.randomGigArtist = randomGig.performance[0].artist.displayName;      \n      \n      this.getSpotifyEmbedUrl(this.spotifyToken, this.randomGigArtist)\n    },\n\n    // The first step in getting data from Spotify API is to do a POST request with our client ID and secret to get an access token in response (From this tutorial: https://www.youtube.com/watch?v=SbelQW2JaDQ)    \n    // The below private method returns a promise (as denoted by 'async'); we store the endpoint response in variable 'result'    \n    async getSpotifyToken () {    \n      const clientId = '471048b4fff14c79b12b08abb6dae22e'\n      const clientSecret = 'd8b25c87a3e248beb461a94b48f5905f'\n      const result = await fetch('https://accounts.spotify.com/api/token', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Authorization': 'Basic ' + btoa(clientId + ':' + clientSecret)\n        },\n        body: 'grant_type=client_credentials'\n      });\n\n      // We await the json result from above and store it in variable 'data' and specifically return the access_token from the json data\n      // We'll use this token to call Spotify API endpoint below\n      const data = await result.json()\n      this.spotifyToken = data.access_token;       \n    },\n    async getSpotifyEmbedUrl(token, artistName) {\n      const artistResult = await fetch(`https://api.spotify.com/v1/search?q=${artistName}&type=artist&limit=1`, {\n        method: 'GET',\n        headers: { 'Authorization' : 'Bearer ' + token }\n      })\n      \n      const spotifyData = await artistResult.json()\n      const spotifyArtistId = spotifyData.artists.items[0].id     \n      this.spotifyEmbedUrl = `https://open.spotify.com/embed/artist/${spotifyArtistId}`\n    }\n  },\n  beforeMount(){\n    this.getSpotifyToken()    \n  }\n}\n</script>\n\n<style>\n\n</style>"]},"metadata":{},"sourceType":"module"}